#Folding Atomata
###Alternative protein viewer for Folding@home.

View the biological machines that run the body! Folding Atomata is a third-party simulation and protein viewer for [Folding@home](http://folding.stanford.edu/home/). It aims to be a drop-in replacement for FAHViewer, the official viewer for F@h.

### System requirements

1. OpenGL 2.1 (GLSL 1.20). This is supported by Nouveau drivers.
2. The Freeglut, GLEW, and GLM libraries.
3. The Linux operating system. Mint/*buntu/Debian preferred.

Freeglut is used to create and manage the window and read user input. GLEW wrangles extensions for OpenGL, which powers the rendering. The GLM library performs linear-algebra operations CPU-side.

### Installation

Currently the only way to install Atomata is to compile it. Luckily, this is pretty easy, especially in Linux. The first trick is to ensure that the necessary components are installed beforehand. Thankfully, installing these libraries is very straightforward with the following command:

**sudo apt-get install libglew-dev freeglut3-dev cmake build-essential**

Then it should be ready to compile. This project supports two compilers: Clang and GCC. I prefer the former because it compiles faster, has better diagnostic messages, and [for other reasons](http://clang.llvm.org/comparison.html). I have shell scripts set up in the _src_ directory that make it easy to compile and run the project. To run them or to compile manually, navigate into the _src_ directory, and run either **./ClangCompileRun** to use Clang, or run **./compileRun** for GCC. This compiles and launches the produced executable.

I'm planning to distribute pre-compiled binaries via [my Launchpad PPA](https://launchpad.net/~jvictors/+archive/gitstable) and via a .deb download.

### What does "Folding Atomata" mean?

It's a play on words, almost a portmanteau. The root is "automaton", (plural automata) which is a self-operating machine. These can be a full-sized machine or robot, or self-operating process such as a [cellular automaton](http://en.wikipedia.org/wiki/Cellular_automaton). The term "automaton" can also refer to [finite-state machines](http://en.wikipedia.org/wiki/Finite-state_machine), a widely-used model that is often used in the context of computer programs or in any other electronic or logical process. "Atomata" has the prefix "atom."

All of this makes sense in the context of this program. Proteins are self-operating machines: not only are they the workhorses in biology, play essential roles in nearly all biological functions and processes, and bind together to create a ribosome and create more of themselves, but they must first fold themselves into a functional three-dimensional structure before they can take on any of these roles. As a protein folds, [it transitions](http://en.wikipedia.org/wiki/File:ACBP_MSM_from_Folding@home.tiff) from one intermediate semi-stable fold to another until it finally reaches its stable native state. A protein can spend upwards of 96% of its folding time in these intermediate states, so scientists often model protein folding using an [energy function and Markov State Models](http://folding.stanford.edu/home/faq/faq-simulation/). MSMs can be represented as finite-state machines, except that the transitions are probabilistic/stochastic rather than deterministic. MSMs are a key component to Folding@home: it is because of them that distributing computing is even an option for simulating protein folding. Each workunit is a piece of this model. This program animates and allows the exploration of the atoms and the overall structure of the protein as the computer processes it.

### Development

The _master_ branch is the unstable development edition. I try to only push compilable versions, but this is not guaranteed. I like to make small commits, so features in the master branch aren't guaranteed to be complete. When I've reached a stable point, I'll tag the commit and create a Github release. These releases generally follow the [milestones](https://github.com/Jesse-V/Folding-Atomata/issues/milestones) and the completeness of their corresponding issues.

The *clean.sh* script in the _src_ directory is useful for cleaning out the files generated by CMake when it builds and compiles the code. Since this process is dependent on the working directory and environment, it makes sense to me to run this script to clean the build environment before I push to Github.

Wherever reasonably possible, the programming style strives to follow http://geosoft.no/development/cppstyle.html with the exception of #85.

### Origin

This project inherits the rendering and game engine developed for [iVoxely](https://github.com/Jesse-V/iVoxely).

